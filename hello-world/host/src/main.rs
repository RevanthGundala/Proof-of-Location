use eyre::Context;
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{HELLO_GUEST_ELF, HELLO_GUEST_ID};
use risc0_zkvm::{default_prover, ExecutorEnv, compute_image_id, serde::to_vec, Receipt};
use color_eyre::eyre::{Result, eyre};
use bonsai_sdk::alpha as bonsai_sdk;
use std::time::Duration;
use hex;

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

        let input: u32 = 15 * u32::pow(2, 27) + 1;
        let _ = get_groth_16_proof(input);
        println!("Hereproof");
        // let env = ExecutorEnv::builder().write(&input).unwrap().build().unwrap();

        // // Obtain the default prover.
        // let prover = default_prover();

        // // Produce a receipt by proving the specified ELF binary.
        // let receipt = prover.prove(env, HELLO_GUEST_ELF).unwrap();

        // // Extract journal of receipt
        // let output: u32 = receipt.journal.decode().unwrap();

        // // Print, notice, after committing to a journal, the private input became public
        // println!("Hello, world! I generated a proof of guest execution! {} is a public output from journal ", output);
}



fn get_groth_16_proof(input_data: u32) -> Result<()> {
    // TODO: Place in .env
    let url = String::from("https://api.bonsai.xyz/swagger-ui/");
    let key = String::from("5TToerj1TJ8NwM6ccLC2B6vPRi97jLks1BPq6Sm6");

    let client = bonsai_sdk::Client::from_parts(url, key, risc0_zkvm::VERSION).unwrap();
    // let client = bonsai_sdk::Client::from_env(risc0_zkvm::VERSION).unwrap();
    
    let METHOD_ELF = HELLO_GUEST_ELF;
    let METHOD_ID = HELLO_GUEST_ID;

    // let image_id = hex::encode(compute_image_id(METHOD_ELF).map_err(|e| eyre!("{:?}", e))?);

    let image_id = hex::encode(compute_image_id(METHOD_ELF).unwrap());
    println!("Image ID: {}", image_id);

    client.upload_img(&image_id, METHOD_ELF.to_vec()).unwrap();

    // Prepare input data and upload it.
    let input_data = to_vec(&input_data).unwrap();
    let input_data = bytemuck::cast_slice(&input_data).to_vec();
    println!("Input data: {:?}", input_data);
    let input_id = client.upload_input(input_data).unwrap();
    // Start a session running the prover
    let session = client.create_session(image_id, input_id, vec![]).unwrap();
    loop {
        let res = session.status(&client)?;
        if res.status == "RUNNING" {
            eprintln!(
                "Current status: {} - state: {} - continue polling...",
                res.status,
                res.state.unwrap_or_default()
            );
            std::thread::sleep(Duration::from_secs(15));
            continue;
        }
        if res.status == "SUCCEEDED" {
            // Download the receipt, containing the output
            let receipt_url = res
                .receipt_url
                .expect("API error, missing receipt on completed session");

            let receipt_buf = client.download(&receipt_url)?;
            let receipt: Receipt = bincode::deserialize(&receipt_buf)?;
            receipt
                .verify(METHOD_ID)
                .expect("Receipt verification failed");
        } else {
            panic!(
                "Workflow exited: {} - | err: {}",
                res.status,
                res.error_msg.unwrap_or_default()
            );
        }

        break;
    }
    run_stark2snark(client, session.uuid)
}


fn run_stark2snark(client: bonsai_sdk::Client, session_id: String) -> Result<()> {
    let snark_session = client.create_snark(session_id)?;
    eprintln!("Created snark session: {}", snark_session.uuid);
    loop {
        let res = snark_session.status(&client)?;
        match res.status.as_str() {
            "RUNNING" => {
                eprintln!("Current status: {} - continue polling...", res.status,);
                std::thread::sleep(Duration::from_secs(15));
                continue;
            }
            "SUCCEEDED" => {
                let snark_receipt = res.output;
                eprintln!("Snark proof!: {snark_receipt:?}");
                break;
            }
            _ => {
                panic!(
                    "Workflow exited: {} err: {}",
                    res.status,
                    res.error_msg.unwrap_or_default()
                );
            }
        }
    }
    Ok(())
}